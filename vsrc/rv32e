//译码模块(指令)
`define INST_TYPE_LUI     5'b01101//U
`define INST_TYPE_AUIPC   5'b00101//U
`define INST_TYPE_JAL     5'b11011
`define INST_TYPE_JALR    5'b11001
`define INST_TYPE_S       5'b01000
`define INST_TYPE_B       5'b11000
`define INST_TYPE_R       5'b01100
`define INST_TYPE_L       5'b00000
`define INST_TYPE_I       5'b00100
`define INST_TYPE_E       5'b11100

`define INST_LUI       7'b01101_11
`define INST_AUIPC     7'b00101_11
`define INST_JAL       7'b11011_11
`define INST_JALR      7'b11001_11
`define INST_LW        7'b00000_11

`define INST_B         7'b11000_11
`define INST_R         7'b01100_11
`define INST_I         7'b00100_11

//ebreak
`define INST_EBREAK       32'h00100073
`define HIT_TRAP          1
`define ABORT             2

// funct3 值定义
`define F3_ADDI    3'b000
`define F3_SLTI    3'b010
`define F3_SLTU    3'b011
`define F3_ANDI    3'b111
`define F3_ORI     3'b110
`define F3_BEQ     3'b000
`define F3_BNE     3'b001
`define F3_BLT     3'b100
`define F3_BGE     3'b101

// ALU 操作码
`define ALU_ADD    4'b0000
`define ALU_SUB    4'b0001
`define ALU_AND    4'b0010
`define ALU_OR     4'b0011
`define ALU_XOR    4'b0100
`define ALU_SLL    4'b0101
`define ALU_SLTU   4'b0110

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
module rv32e (
    input         clk,
    input         reset
);

    wire [31:0]  pc;
    wire [31:0]  instr;
    wire [6:0]   opcode;
    wire [4:0]   rs1, rs2, rd;
    wire [31:0]  imm;
    wire [2:0]   func3;
    wire [6:0]   func7;
    wire         RegWrite;
    wire         MemWrite;
    wire         MemRead;
    wire [31:0]  rs1_val, rs2_val;
    wire [31:0]  wb_data;
    wire [31:0]  jal_target;
    wire [31:0]  jalr_target;
    wire         is_jal, is_jalr;
    wire [31:0]  data_out;
    wire [3:0]   alu_op;
    wire [31:0]  alu_result;
    wire         alu_zero;
    wire         alu_less;
    wire         take_branch;
    // 取指模块
    IF if_stage (
        .clk(clk),
        .reset(reset),
        .branch_target(is_jal ? jal_target : jalr_target),
        .pc_src(is_jal | is_jalr | take_branch),
        .pc(pc),
        .instr(instr)
    );

    // 译码模块
    ID id_stage (
        .instr(instr),
        .opcode(opcode),
        .rs1(rs1),
        .rs2(rs2),
        .rd(rd),
        .imm(imm),
        .func3(func3),
        .func7(func7),
        .RegWrite(RegWrite),
        .MemWrite(MemWrite),
        .MemRead(MemRead),
        .alu_op(alu_op)
    );

    // 寄存器文件
    RegFile regfile (
        .clk(clk),
        .rs1(rs1),
        .rs2(rs2),
        .rd(rd),
        .we(RegWrite),
        .wd(wb_data),
        .rs1_val(rs1_val),
        .rs2_val(rs2_val)
    );
    // ALU模块
    ALU alu (
        .alu_op(alu_op),
        .a(rs1_val),
        .b((opcode[6:2] == `INST_TYPE_R || opcode[6:2] == `INST_TYPE_B) ? rs2_val : imm), // R-type用rs2_val，I-type用imm
        .result(alu_result),
        .zero(alu_zero),
        .less(alu_less)
    );
    // 内存访问模块
    MEM mem_stage (
        .clk(clk),
        .MemRead(MemRead),
        .MemWrite(MemWrite),
        .addr(rs1_val + imm),
        .data_in(rs2_val),
        .data_out(data_out)
    );

    // 跳转目标计算
    assign jal_target = pc + imm;
    assign jalr_target = (rs1_val + imm) & ~32'h1;
    assign is_jal = (opcode == `INST_JAL);
    assign is_jalr = (opcode == `INST_JALR) & (func3 == 3'b000);
    assign take_branch = (opcode == `INST_B) && (//B类型
        (func3 == `F3_BNE && !alu_zero) ||//bne
        (func3 == `F3_BEQ && alu_zero) ||//beq
        (func3 == `F3_BLT && alu_less) ||//blt
        (func3 == `F3_BGE && !alu_less) //bge
    ); 
    // 写回数据选择
    assign wb_data = (opcode == `INST_LUI) ? imm :                   // LUI
                     (opcode == `INST_AUIPC) ? (pc + imm) :            // AUIPC
                     (opcode == `INST_JAL || opcode == `INST_JALR) ? (pc + 4) : // JAL, JALR
                     (opcode == `INST_LW) ? data_out :              // lw
                     (opcode == `INST_R || opcode == `INST_I) ? alu_result : 32'b0; // R-type, I-type

endmodule

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
// 取指模块
module IF (
    input         clk,
    input         reset,
    input  [31:0] branch_target,
    input         pc_src,
    output reg [31:0] pc,
    output reg [31:0] instr
);
    
    import "DPI-C" function int unsigned pmem_read(input int unsigned raddr, input int len);
    

    always @(posedge clk or posedge reset) begin
        if (reset)      pc <= 32'h7fff_fffc; // 初始PC值
        else if (pc_src) pc <= branch_target;
        else            pc <= pc + 4;
    end

    always @(*) begin
        instr=pmem_read(pc,4); // 同步读取指令
        // $display("PC=0x%08x | instr=0x%08x",pc,instr);
    end

endmodule

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
// 译码模块
module ID (
    input  [31:0] instr,
    output reg [6:0]  opcode,
    output reg [4:0]  rs1,
    output reg [4:0]  rs2,
    output reg [4:0]  rd,
    output reg [31:0] imm,
    output reg [2:0]  func3,
    output reg [6:0]  func7,
    output reg        RegWrite,
    output reg        MemWrite,
    output reg        MemRead,
    output reg [3:0]  alu_op
);
    import "DPI-C" function void ebreak(input int station, input int inst);

    reg [31:0] immI;
    reg [31:0] immU;
    reg [31:0] immS;
    reg [31:0] immB;
    reg [31:0] immJ;
    reg [31:0] immR;
    reg [4:0] get_opcode;
    
    assign immI = {{20{instr[31]}}, instr[31:20]};
    assign immU = {instr[31:12], 12'b0};
    assign immS = {{20{instr[31]}}, instr[31:25], instr[11:7]};
    assign immB = {{20{instr[31]}}, instr[7], instr[30:25], instr[11:8], 1'b0};
    assign immJ = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};
    assign immR = 32'b0;

    always @(*) begin
        opcode = instr[6:0];
        rs1    = instr[19:15];
        rs2    = instr[24:20];
        rd     = instr[11:7];
        func3  = instr[14:12];
        func7  = instr[31:25];

        imm      = 32'b0;
        RegWrite = 1'b0;
        MemWrite = 1'b0;
        MemRead  = 1'b0;
        alu_op   = `ALU_ADD;
 
        assign get_opcode = opcode[6:2];

        case(get_opcode)
            // LUI
            `INST_TYPE_LUI: begin
                imm = immU;
                RegWrite = 1'b1;
            end
            // AUIPC
            `INST_TYPE_AUIPC: begin
                imm = immU;
                RegWrite = 1'b1;
                alu_op=`ALU_ADD;//PC+imm
            end
            // JAL
            `INST_TYPE_JAL: begin
                imm = immJ;
                RegWrite = 1'b1;
            end
            // JALR
            `INST_TYPE_JALR: begin
                if (func3 == 3'b000) begin
                    imm = immI;
                    RegWrite = 1'b1;
                end
            end
            // SW
            `INST_TYPE_S: begin
                if (func3 == 3'b010) begin
                    imm = immS;
                    MemWrite = 1'b1;
                end
            end
            `INST_TYPE_L: begin
                if(func3==3'b010) begin//lw
                    imm=immI;
                    RegWrite=1'b1;
                    MemRead=1'b1;
                end
            end
            `INST_TYPE_R: begin
                RegWrite = 1'b1;
                imm = immR;
                case (func3)
                    3'b000: alu_op = (func7[5]) ? `ALU_SUB : `ALU_ADD; // add, sub
                    `F3_ANDI: alu_op = `ALU_AND; // and
                    `F3_ORI: alu_op = `ALU_OR; // or
                    3'b100: alu_op = `ALU_XOR;// xor
                    default: begin
                        ebreak(`ABORT, instr);
                        $display("ID : Unknown R instruction with func3 = %b", func3);
                    end
                endcase
            end
            `INST_TYPE_I: begin
                imm=immI;
                RegWrite=1'b1;
                case(func3)
                    `F3_ADDI: alu_op = `ALU_ADD;
                    `F3_ANDI: alu_op = `ALU_AND;
                    `F3_ORI:  alu_op = `ALU_OR;
                    `F3_SLTU: alu_op = `ALU_SLTU;//sltiu(支持seqz)
                    default:  begin
                        ebreak(`ABORT,instr);
                        $display("ID : Unknown I instruction with func3 = %b", func3);
                    end
                endcase
            end
            `INST_TYPE_B: begin
                // if (func3 == 3'b001) begin  // bne
                //     imm = immB;
                //     alu_op = 4'b0001; // 减法，用于比较
                // end
                imm=immB;
                alu_op=`ALU_SUB;//用于减法比较
            end
            `INST_TYPE_E: begin
                if(instr==`INST_EBREAK) begin
                    ebreak(`HIT_TRAP,instr);
                    $display("ebreak instruction");
                end
            end
            default: begin
                    ebreak(`ABORT, instr);
                    $display("ID : Unknow instruction with inst = %h", instr);
                end
        endcase
    end

endmodule

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
// 寄存器文件
module RegFile (
    input         clk,
    input  [4:0]  rs1,
    input  [4:0]  rs2,
    input  [4:0]  rd,
    input         we,
    input  [31:0] wd,
    output [31:0] rs1_val,
    output [31:0] rs2_val
);
    
    
    reg [31:0] regs [0:31]; // 32个寄存器

    assign rs1_val = (rs1 != 0) ? regs[rs1] : 0;
    assign rs2_val = (rs2 != 0) ? regs[rs2] : 0;

    always @(posedge clk) begin
        if (we && rd != 0) regs[rd] <= wd;
    end

endmodule

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
// 内存模块
module MEM (
    input         clk,
    input         MemRead,
    input         MemWrite,
    input  [31:0] addr,
    input  [31:0] data_in,
    output reg [31:0] data_out
);
    
    import "DPI-C" function int unsigned pmem_read(input int unsigned raddr, input int len);
    import "DPI-C" function void pmem_write(input int unsigned waddr, input int unsigned wdata, input int len);
    
    // assign data_out = MemRead ? 32'b0 : pmem_read(addr,4);

    // always @(posedge clk) begin
    //     if (MemWrite) pmem_write(addr, data_in, 4);
    // end
    always @(posedge clk) begin
        if(MemRead) data_out = pmem_read(addr,4);
        else if(MemWrite) pmem_write(addr,data_in,4);
        else data_out = 32'b0;
    end

endmodule

`include "/home/furina/ysyx-workbench/npc/vsrc/defines.v"
// ALU模块
module ALU (
    input      [3:0]   alu_op,
    input      [31:0]  a,
    input      [31:0]  b,
    output reg [31:0]  result,
    output             zero,
    output             less
);
    import "DPI-C" function void ebreak(input int station, input int inst);
    always @(*) begin
        // Less 信号生成
        if (alu_op[3])
            less = (a < b) ? 1'b1 : 1'b0;                    // 无符号比较 (sltiu)
        else
            less = ($signed(a) < $signed(b)) ? 1'b1 : 1'b0;  // 有符号比较 (slt)

        case (alu_op)
            `ALU_ADD:  result = a + b;  // 加法 (add, addi)
            `ALU_SUB:  result = a - b;  // 减法 (sub, bne)
            `ALU_AND:  result = a & b;  // 与 (and)
            `ALU_OR:   result = a | b;  // 或 (or)
            `ALU_XOR:  result = a ^ b;  // 异或(xor)
            `ALU_SLTU: result = {31'b0, less};//无符号小于比较(sltiu)
            default: begin
                result = 32'b0;
                ebreak(`ABORT,32'hdeadbeef);
                $display("ALU : Unknown alu_op = %b",alu_op);
            end
        endcase
    end

    assign zero = (result == 32'b0);
    // assign less = ($signed(a) < $signed(b)); //有符号比较
endmodule